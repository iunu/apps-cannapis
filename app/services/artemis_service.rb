# frozen_string_literal: true

class ArtemisService
  def initialize(account, batch_id, facility_id)
    @artemis = account.client
    @batch_id = batch_id
    @facility_id = facility_id
  end

  def get_facility(id = nil)
    @artemis.facility(id || @facility_id)
  end

  def get_batch(add = 'zone,zone.sub_stage,barcodes,custom_data,seeding_unit,sub_zone,custom_data.custom_field')
    get_batch_by_id(@batch_id, add)
  end

  def get_batch_by_id(id, add = 'zone,zone.sub_stage,barcodes,custom_data,seeding_unit,sub_zone,custom_data.custom_field')
    get_facility.batch(id, include: add, force: true)
  end

  def get_completion(id, add = 'action_result,crop_batch_state,crop_batch_state.seeding_unit,crop_batch_state.zone.sub_stage')
    @artemis.find_one('completions', id, facility_id: @facility_id, include: add, force: true)
  end

  # This will get the current items from the batch
  # This probably should not be used because it could provide
  #   items from the future after the current_completion was performed.
  def get_batch_items(seeding_unit_id, include: 'barcodes,seeding_unit')
    @artemis.facility(@facility_id)
            .batch(@batch_id)
            .items(seeding_unit_id: seeding_unit_id, include: include)

  # TODO: handle empty item lists in the API gem
  rescue NoMethodError => e
    raise unless e.message.match?(/undefined method `each' for nil/)

    []
  end

  def get_zone(zone_id, include: nil)
    @artemis.facility(@facility_id)
            .zone(zone_id, include: include)
  end

  def get_resource_unit(resource_unit_id, include: nil)
    @artemis.facility(@facility_id)
            .resource_unit(resource_unit_id, include: ['crop_variety', include].compact.join(','))
  end

  def get_resource_units(include: nil)
    @artemis.facility(@facility_id)
            .resource_units(include: ['crop_variety', include].compact.join(','))
  end

  def get_child_completions(parent_id, filter: {})
    child_completions = ArtemisApi::Completion.find_all(
      facility_id: @facility_id,
      client: @artemis,
      filters: { parent_id: parent_id }.merge(filter)
    )

    # portal not filtering by parent_id, so we do it here for now
    child_completions.select { |completion| completion.parent_id == parent_id }
  end

  def get_related_completions(action_type = nil)
    get_batch.completions.select { |c| c.action_type == action_type&.to_s && c.status == 'active' }
  end
end
